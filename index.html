<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h1>Texturas y Render Target</h1>
				<h5>Daverson Parra</h5>
				<h5>Jesus Castelblanco</h5>
				<h5>Brayan Perez</h5>
				<footer>2020</footer>
			</section>
			<section>
				<section>
					<h1>Texturas</h1>
				</section>
				<section>
					<h3>Introduccion</h3>
					<p>xxxxxxxx x xxxxxxxxxxxxx xxxxxxxx
					</p>
				</section>
				<section>
					<h3>TextureLoader</h3>
					</p>
					<pre><code data-trim data-noescape>
						const loader = new THREE.TextureLoader();
 
						const material = new THREE.MeshBasicMaterial({
						color: 0xFF8844,
						map: loader.load('resources/images/wall.jpg'),
						});
						</code>
						</pre>
				</section>
				<section>
					<p>
						Para este ejercicio se va a usar MeshBasicMaterial para no requerir el uso de las luces.
					</p>
					<div>
						<pre><code data-trim data-noescape>
							const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

							const cubes = [];  // just an array we can use to rotate the cubes
							const loader = new THREE.TextureLoader();
						  
							const material = new THREE.MeshBasicMaterial({
							  map: loader.load('https://threejsfundamentals.org/threejs/resources/images/wall.jpg'),
							});
							const cube = new THREE.Mesh(geometry, material);
							</code>
							</pre>
					</div>
				</section>
				<section data-background-iframe="https://threejsfundamentals.org/threejs/threejs-textured-cube.html"
					data-background-interactive>
				</section>
				<section>
					<div class="threejs_center">
						<div>
							<img src="https://threejsfundamentals.org/threejs/resources/images/flower-1.jpg"
								style="width: 100px;" class="border">
							<img src="https://threejsfundamentals.org/threejs/resources/images/flower-2.jpg"
								style="width: 100px;" class="border">
							<img src="https://threejsfundamentals.org/threejs/resources/images/flower-3.jpg"
								style="width: 100px;" class="border">
						</div>
						<div>
							<img src="https://threejsfundamentals.org/threejs/resources/images/flower-4.jpg"
								style="width: 100px;" class="border">
							<img src="https://threejsfundamentals.org/threejs/resources/images/flower-5.jpg"
								style="width: 100px;" class="border">
							<img src="https://threejsfundamentals.org/threejs/resources/images/flower-6.jpg"
								style="width: 100px;" class="border">
						</div>
					</div>
					<div>
						<pre><code data-trim data-noescape>
						const loader = new THREE.TextureLoader();
 
						const material = new THREE.MeshBasicMaterial({
						map: loader.load('resources/images/wall.jpg'),
						});
						const materials = [
						new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-1.jpg')}),
						new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-2.jpg')}),
						new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-3.jpg')}),
						new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-4.jpg')}),
						new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-5.jpg')}),
						new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-6.jpg')}),
						];
						const cube = new THREE.Mesh(geometry, material);
						const cube = new THREE.Mesh(geometry, materials);
						</code>
						</pre>
					</div>
				</section>
				<section
					data-background-iframe="https://threejsfundamentals.org/threejs/threejs-textured-cube-6-textures.html"
					data-background-interactive></section>
			</section>
			<section>
				<section>
					<h1>Caracteristicas de las texturas</h1>
				</section>
				<section>
					<h3>Uso de la memoria</h3>
					<p>
						En THREE.js el espacio que ocupa una textura se determina de la siguiente forma
					<pre><code data-trim data-noescape>
								width * height * 4 * 1.33bytes
								  </code></pre>
					La compresión de la imagen no influye sobre el peso, unicamente su alto y ancho.
					</p>
				</section>
				<section id="weightexample">
					<img src="https://cdn.pixabay.com/photo/2014/09/24/16/28/bricks-459299__340.jpg"
						alt="https://cdn.pixabay.com/photo/2014/09/24/16/28/bricks-459299__340.jpg">
					<p>
						Por ejemplo para esta textura su peso será:
					<pre><code data-trim data-noescape>
							{{width}} * {{height}} * 4 * 1.33 = {{result}}MB
						</code>
					</pre>
					</p>
				</section>
				<section>
					<h3>JPG vs PNG</h3>
					<p>
						Debido a que las texturas en sí son imagenes, por lo general exportados como JPG o PNG, es
						valido considerar que las imagenes PNG admiten transparencia lo cual incrementa su peso, y
						aunque frente a la descarga pueden tardar más para
						WebGL el consumo de memoria es indiferente al cargarse como textura.
					</p>
				</section>
				<section>
					<h3>Filtering and Mips</h3>
					<p>
						Al tener una textura aplicada a una geometria u objeto cuyo tamaño es inferior a
						la textura, la GPU realizará la plicación mediante Mipmaps.
						Mipmap son copias de la textura con la mitad de su ancho y alto que su mip map anterior,
						combinando sus pixeles hasta tener un mip de 1x1.

						<img src="https://threejsfundamentals.org/threejs/lessons/resources/images/mipmap-low-res-enlarged.png"
							alt="https://threejsfundamentals.org/threejs/lessons/resources/images/mipmap-low-res-enlarged.png">
					</p>
				</section>
				<section>
					<p>
						Sí el tamaño de la textura debe ser escalado a un tamaño mayor o menor que su tamaño original,
						se
						utilizarán los filtros Lineal o Más cercano.
					<pre><code data-trim data-noescape>//Si el tamaño es superior se debe establecer 
//la propiedad texture.magFilter
THREE.LinearFilter
THREE.NearestFilter</code></pre>

					<pre><code data-trim data-noescape>//Si el tamaño es superior se debe establecer 
//la propiedad texture.minFilter
THREE.NearestFilter
THREE.LinearFilter
THREE.NearestMipmapNearestFilter
THREE.NearestMipmapLinearFilter
THREE.LinearMipmapNearestFilter
THREE.LinearMipmapLinearFilter</code>
					</pre>
					</p>
				</section>
				<section data-background-iframe="https://threejs.org/examples/webgl_materials_texture_filters.html"
					data-background-interactive>

				</section>
				<section>
					<h3>Repeating, offseting, rotating, wrapping a texture</h3>
					<p>
						Brayan
					</p>
				</section>
			</section>
			<section>
				<section>
					<h1>Render Target</h1>
				</section>
				<section>Brayan</section>
				<section data-background-iframe="https://threejsfundamentals.org/threejs/threejs-render-target.html"
					data-background-interactive>
				</section>
			</section>
		</div>
	</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});


		var app = new Vue({
			el: '#weightexample',
			data: {
				width: 522,
				height: 340,
			},
			created() {
				this.calcularPeso()
			},
			computed: {
				result() {
					return Math.round((3024 * 3761 * 4 * 1.33) / Math.pow(1024, 2))
				}
			},
			methods: {
				calcularPeso() {
					var vm = this
					const img = new Image();
					img.onload = function () {
						vm.width = this.width;
						vm.height = this.height;
					}
					img.src = 'https://cdn.pixabay.com/photo/2014/09/24/16/28/bricks-459299__340.jpg';
				}
			}
		})

	</script>
</body>

</html>